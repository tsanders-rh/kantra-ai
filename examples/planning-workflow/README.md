# Planning Workflow Example

This directory contains example files demonstrating the phased migration workflow with `kantra-ai plan` and `kantra-ai execute`.

## Files

### example-plan.yaml

A sample migration plan generated by `kantra-ai plan` showing:

- **3 phases**: Critical mandatory, mandatory medium-effort, and optional improvements
- **Risk assessment**: Each phase has risk level (high/medium/low) with explanation
- **AI reasoning**: Detailed explanations of WHY violations are grouped together
- **Effort estimation**: Effort ranges and estimated costs/duration per phase
- **Incident details**: File paths and line numbers for each violation

**Key Features Demonstrated:**
- Risk-based grouping (critical mandatory first, optional last)
- Category grouping (javaxâ†’jakarta namespace changes together)
- Deferred phases (can be skipped during execution)
- Cost estimates for budgeting

### example-state.yaml

A sample execution state file showing partial progress:

- **Phase 1 completed**: All 41 fixes applied successfully
- **Phases 2-3 pending**: Not yet executed
- **Incident-level tracking**: Each fix recorded with cost and timestamp
- **Resume ready**: Can resume from Phase 2 if execution was interrupted

**Key Features Demonstrated:**
- Incident-level state tracking
- Cost tracking per violation and overall
- Timestamp tracking for audit trail
- Resume capability (no last_failure means clean execution)

## Usage Example

### 1. Generate Your Own Plan

```bash
kantra-ai plan \
  --analysis=./path/to/konveyor/output.yaml \
  --input=./path/to/your-app \
  --provider=claude
```

This creates `.kantra-ai-plan.yaml` similar to `example-plan.yaml`.

### 2. Review and Edit the Plan

```bash
# View the generated plan
cat .kantra-ai-plan.yaml

# Edit to defer phases or adjust order
vim .kantra-ai-plan.yaml

# Example edits:
# - Set deferred: true on phase-3 to skip optional improvements
# - Reorder phases if needed (change order: values)
# - Add notes in explanation fields
```

### 3. Execute the Plan

```bash
# Execute all non-deferred phases
kantra-ai execute \
  --input=./path/to/your-app \
  --provider=claude

# Execute a specific phase only
kantra-ai execute \
  --input=./path/to/your-app \
  --provider=claude \
  --phase=phase-1
```

This creates `.kantra-ai-state.yaml` similar to `example-state.yaml`.

### 4. Resume from Failures

If execution fails mid-phase:

```bash
# The state file tracks the failure point
cat .kantra-ai-state.yaml
# Shows last_failure with incident URI and error message

# Resume from the failure point
kantra-ai execute \
  --input=./path/to/your-app \
  --provider=claude \
  --resume

# Only failed/pending incidents will be retried
```

## Plan File Structure

```yaml
version: "1.0"              # Plan schema version
metadata:
  provider: "claude"        # AI provider used
  created_at: "..."         # Timestamp
  total_violations: 45      # Total violations in plan
  estimated_cost: 4.30      # Total estimated cost

phases:
  - id: "phase-1"           # Unique phase identifier
    name: "..."             # Human-readable phase name
    order: 1                # Execution order (1, 2, 3...)
    risk: high              # Risk level: low|medium|high
    category: mandatory     # Primary category
    effort_range: [5, 7]    # Min-max effort levels
    explanation: |          # AI-generated explanation
      Why these violations are grouped...
    estimated_cost: 1.85    # Phase cost estimate
    estimated_duration_minutes: 25
    deferred: false         # Set true to skip this phase

    violations:
      - violation_id: "..." # Violation identifier
        description: "..."  # What needs to be fixed
        category: "..."     # mandatory|optional|potential
        effort: 7           # Effort level (0-10)
        incident_count: 23  # Number of occurrences
        incidents:          # List of specific occurrences
          - uri: "..."      # File path (file:/// URI)
            line_number: 3  # Line number in file
            message: "..."  # Specific issue description
```

## State File Structure

```yaml
version: "1.0"
plan_file: ".kantra-ai-plan.yaml"  # Link to plan file
started_at: "..."                  # Execution start time
updated_at: "..."                  # Last update time

execution_summary:
  total_phases: 3                  # Total phases in plan
  completed_phases: 1              # Successfully completed
  pending_phases: 2                # Not yet started
  failed_phases: 0                 # Failed to complete
  total_cost: 1.85                 # Cost so far
  total_fixes_applied: 41          # Successful fixes
  failed_fixes: 0                  # Failed fixes

phases:
  - phase_id: "phase-1"
    status: completed              # pending|in_progress|completed|failed
    started_at: "..."
    completed_at: "..."
    fixes_applied: 41
    cost: 1.85

violations:
  violation-id:
    status: completed              # Violation-level status
    total_incidents: 23
    completed_incidents: 23
    failed_incidents: 0
    cost: 1.15
    incidents:
      "file:///path:line":
        status: completed          # Incident-level status
        cost: 0.05
        timestamp: "..."

last_failure:                      # Only set if a fix failed
  phase_id: "phase-2"
  violation_id: "..."
  incident_uri: "..."
  error: "..."                     # Error message
```

## Interactive Phase Approval

For full control, use interactive mode during plan generation:

```bash
kantra-ai plan \
  --analysis=./analysis/output.yaml \
  --input=./your-app \
  --provider=claude \
  --interactive
```

You'll see each phase with AI explanation and can:
- **[a]** Approve and continue
- **[d]** Defer (skip this phase)
- **[v]** View incident details
- **[q]** Quit and save plan

This lets you review AI reasoning and defer risky/optional phases before execution starts.

## Best Practices

1. **Review AI Explanations**: Read the `explanation` field for each phase to understand the grouping rationale

2. **Start with High-Risk Phases**: The AI orders phases by priority, but you can defer optional phases

3. **Execute One Phase at a Time**: Use `--phase=phase-1` for incremental migration

4. **Check State After Each Phase**: Review `.kantra-ai-state.yaml` to verify costs and success rates

5. **Use Dry-Run First**: Test with `--dry-run` before applying changes

6. **Combine with Git**: Use `--git-commit=per-violation` to create atomic commits

7. **Enable Verification**: Add `--verify=test` to catch breaking changes immediately

## Cost Estimation

The example plan shows realistic cost estimates:

- **Phase 1** (41 incidents, high complexity): ~$1.85
- **Phase 2** (2 incidents, XML updates): ~$0.95
- **Phase 3** (12 incidents, logging): ~$1.50
- **Total**: ~$4.30

Actual costs may vary based on:
- File complexity
- Context size (larger files cost more)
- AI provider and model (GPT-4 vs Claude vs Sonnet)
- Number of fix attempts (retries on failures)

Use `--dry-run` to get accurate estimates before executing.

## Resuming After Interruption

The state file makes execution fully resumable:

```bash
# If kantra-ai execute is interrupted (Ctrl+C, crash, timeout):

# 1. Check the state
cat .kantra-ai-state.yaml
# Shows last completed incident and any failures

# 2. Resume execution
kantra-ai execute --input=./your-app --provider=claude --resume

# 3. Execution continues from the last incomplete incident
# Already-completed fixes are skipped automatically
```

## See Also

- [Main README](../../README.md) - Full documentation
- [DESIGN.md](../../docs/design/DESIGN.md) - Architecture and design decisions
- [PLANNING_WORKFLOW_DESIGN.md](../../docs/design/PLANNING_WORKFLOW_DESIGN.md) - Detailed planning workflow design
