package violation

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// LoadAnalysis loads and parses a Konveyor output.yaml file
func LoadAnalysis(analysisPath string) (*Analysis, error) {
	// Check if path is a directory (contains output.yaml) or direct file path
	path := analysisPath
	if fi, err := os.Stat(path); err == nil && fi.IsDir() {
		path = filepath.Join(path, "output.yaml")
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read analysis file '%s': %w\n\n"+
			"Please verify:\n"+
			"  1. The file exists and path is correct\n"+
			"  2. You have read permissions: chmod +r %s\n"+
			"  3. The file is a Konveyor analysis output (output.yaml)\n\n"+
			"To generate analysis output:\n"+
			"  kantra analyze --input=./your-app --output=./analysis",
			path, err, path)
	}

	var analysis Analysis
	if err := yaml.Unmarshal(data, &analysis); err != nil {
		return nil, fmt.Errorf("failed to parse analysis YAML '%s': %w\n\n"+
			"The file is not valid YAML or doesn't match Konveyor output format.\n\n"+
			"Please verify:\n"+
			"  1. The file was generated by Konveyor's 'kantra analyze' command\n"+
			"  2. The file hasn't been manually edited or corrupted\n"+
			"  3. You're using a compatible version of Konveyor\n\n"+
			"Expected format:\n"+
			"  ---\n"+
			"  violations:\n"+
			"    - name: violation-name\n"+
			"      description: ...\n"+
			"      category: mandatory|optional|potential\n"+
			"      incidents:\n"+
			"        - uri: file:///path/to/file.java\n"+
			"          lineNumber: 10",
			path, err)
	}

	return &analysis, nil
}

// FilterViolations filters violations based on criteria
func (a *Analysis) FilterViolations(violationIDs []string, categories []string, maxEffort int) []Violation {
	if len(violationIDs) == 0 && len(categories) == 0 && maxEffort == 0 {
		return a.Violations
	}

	var filtered []Violation

	for _, v := range a.Violations {
		// Filter by ID if specified
		if len(violationIDs) > 0 {
			found := false
			for _, id := range violationIDs {
				if v.ID == id {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}

		// Filter by category if specified
		if len(categories) > 0 {
			found := false
			for _, cat := range categories {
				if v.Category == cat {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}

		// Filter by effort if specified
		if maxEffort > 0 && v.Effort > maxEffort {
			continue
		}

		filtered = append(filtered, v)
	}

	return filtered
}
