package violation

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// LoadAnalysis loads and parses a Konveyor output.yaml file.
// It supports both native Kantra format (array of rulesets) and simplified format (violations array).
func LoadAnalysis(analysisPath string) (*Analysis, error) {
	// Check if path is a directory (contains output.yaml) or direct file path
	path := analysisPath
	if fi, err := os.Stat(path); err == nil && fi.IsDir() {
		path = filepath.Join(path, "output.yaml")
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read analysis file '%s': %w\n\n"+
			"Please verify:\n"+
			"  1. The file exists and path is correct\n"+
			"  2. You have read permissions: chmod +r %s\n"+
			"  3. The file is a Konveyor analysis output (output.yaml)\n\n"+
			"To generate analysis output:\n"+
			"  kantra analyze --input=./your-app --output=./analysis",
			path, err, path)
	}

	// Try to parse as native Kantra format first (array of rulesets)
	var nativeRulesets []NativeKantraRuleset
	if err := yaml.Unmarshal(data, &nativeRulesets); err == nil && len(nativeRulesets) > 0 {
		// Successfully parsed as native format - convert to internal format
		return convertNativeToAnalysis(nativeRulesets), nil
	}

	// Fall back to simplified format (violations array)
	var analysis Analysis
	if err := yaml.Unmarshal(data, &analysis); err != nil {
		return nil, fmt.Errorf("failed to parse analysis YAML '%s': %w\n\n"+
			"The file is not valid YAML or doesn't match Konveyor output format.\n\n"+
			"Please verify:\n"+
			"  1. The file was generated by Konveyor's 'kantra analyze' command\n"+
			"  2. The file hasn't been manually edited or corrupted\n"+
			"  3. You're using a compatible version of Konveyor\n\n"+
			"Supported formats:\n"+
			"  1. Native Kantra format (array of rulesets)\n"+
			"  2. Simplified format (violations array)",
			path, err)
	}

	return &analysis, nil
}

// convertNativeToAnalysis converts native Kantra format to internal Analysis format
func convertNativeToAnalysis(rulesets []NativeKantraRuleset) *Analysis {
	analysis := &Analysis{
		Violations: []Violation{},
	}

	for _, ruleset := range rulesets {
		for violationID, nativeViolation := range ruleset.Violations {
			// Skip violations without incidents
			if len(nativeViolation.Incidents) == 0 {
				continue
			}

			violation := Violation{
				ID:          violationID,
				Description: nativeViolation.Description,
				Category:    nativeViolation.Category,
				Effort:      nativeViolation.Effort,
				RuleSet:     ruleset.Name,
				Rule: Rule{
					ID:      violationID,
					Message: nativeViolation.Description,
					RuleSet: ruleset.Name,
					Labels:  nativeViolation.Labels,
				},
				Incidents: nativeViolation.Incidents,
			}

			analysis.Violations = append(analysis.Violations, violation)
		}
	}

	return analysis
}

// FilterViolations filters violations based on criteria
func (a *Analysis) FilterViolations(violationIDs []string, categories []string, maxEffort int) []Violation {
	if len(violationIDs) == 0 && len(categories) == 0 && maxEffort == 0 {
		return a.Violations
	}

	var filtered []Violation

	for _, v := range a.Violations {
		// Filter by ID if specified
		if len(violationIDs) > 0 {
			found := false
			for _, id := range violationIDs {
				if v.ID == id {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}

		// Filter by category if specified
		if len(categories) > 0 {
			found := false
			for _, cat := range categories {
				if v.Category == cat {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}

		// Filter by effort if specified
		if maxEffort > 0 && v.Effort > maxEffort {
			continue
		}

		filtered = append(filtered, v)
	}

	return filtered
}
